#!/usr/bin/env ksh 
# Ok, i will remember to patch it later.
# shellcheck disable=SC1090,SC1091,SC2006,SC2059

# Otto-PKG - Ein Paketmanager, der Pakete über BitTorrent (und nun HTTP) herunterlädt.

# Caldera License (a.k.a 4-Clause BSD).
# Copyright (c) MMXX, Luiz Antônio Rangel et Projeto Pindorama;
# Read LICENSE.txt @ master branch root (GitHub) for the complete license.

# Include Files
. /etc/make.cfg
. /usr/lib/otto/colors.shi
. /usr/lib/otto/blink.shi
. /usr/lib/otto/txtwait.shi
. /usr/lib/otto/posix-alt.shi

# Program Specifications
binary_name="`basename ${0}`"
ausgabe='0.8'
PKG_FORMT='.psl'
INDEXFILE='.otidx'
PKG_COMPSS='7z'
HOST_OS="`uname -s`"
LANG='POSIX'
LC_ALL="${LANG}"
#ifdef
[ -z "${DROP_SHELL}" ] && SHELL='ksh' || SHELL="${DROP_SHELL}"
mirror_basename=${${MIRROR#*//}%%/*}
export binary_name ausgabe PKG_FORMT INDEXFILE PKG_COMPSS HOST_OS LANG LC_ALL SHELL mirror_basename

# Export alias
alias chdir='cd' # This shall be commented when /bin/sh already has a native "chdir" command/system call.
alias editor="/usr/bin/env ${EDITOR}"
alias sourcelocalpkginfo=". "${PKGDIR}"/"${TORRENT}"/pkginfo"
alias getPKG_FILENAME="printf '%s' "${NAME}" | tr ' ' '.'"

# Script Functions

# ARE YA CHECKING SON?
Checkroot(){
  if [ "`whoami`" != 'root' ] && [ "`whoami`" != 'toor' ]; then
    printf '%b' "${YELLOW}WARNING$END: It looks like you are not logged into toor nor root user...\nWould you like to install the program on the highest userland layer (${HIUSR}) instead of installing directly on the root of the system?\n${YELLOW}WARNING$END: Some packages ${BOLD}cannot$END be installed on the highest userland layer under any circunstances.\nRegarding the first (and only) question: [Y,N]? "
    read ANTWORTEN
    if [grep -iq '^y' <<< "$ANTWORTEN"]; then
      USRDIR="${HIUSR}"
      USRBIN="${HIUSRBIN}"
      ETC="${HIETC}"
      SRCDIR="${HISRCDIR}"
      DIRISTATE=2
      export USRDIR USRBIN ETC SRCDIR DIRISTATE
    else
      printf '%s\n' "${RED}ERROR$END: The current user denied local installation. Exit code is 130."
      exit 130
    fi
  else
    LOINSTDIR='/var/otto/installed/pkg'
    INSTDIR=${LOINSTDIR}
    USRDIR="${LOUSR}"
    USRBIN="${LOUSRBIN}"
    ETC="${LOETC}"
    SRCDIR="${LOSRCDIR}"
    DIRISTATE='1'
    export USRDIR USRBIN ETC SRCDIR DIRISTATE
  fi
}

CheckNetwork(){
  # ${MIRROR} is applyed only in packages officially created, unofficial packages probabily will use some custom domain.
  printf '%s' 'Checking network connection'
  txtwait
  if [ `printf "GET ${mirror_basename} HTTP/1.0\n\n" | netcat "${mirror_basename}" 80 > /dev/null 2>&1` ]; then
    printf '%b\n' "[ ${GREEN}O.K.$END ]"
    return 0
  else
    printf '%b\n' "[ ${RED}FAILED$END ]"
    printf '%b\n' "${RED}ERROR$END: Network is unreachable or server is down. Exit code is 11."
    exit 11
  fi
}

CheckParameters(){
  if [ -z "${OPTARG}" ]; then
    printf '%s\n' "${RED}ERROR$END: Insufficient parameters. Exit code is 1."
    exit 1
  fi
}

CheckDisk(){
  BENUTZT=`df -m / | tail -1 | grep '[0-9]' | awk '{print $3}'`
  DSKVERF=`df -m / | tail -1 | grep '[0-9]' | awk '{print $4}'`
  DSKGROSSE=$[${BENUTZT} + ${DSKVERF}]
  PKGGROSSE_FILE=`du -sk "${SRCDIR}"/uncompressed-"${PKG_FILENAME}"/src.tar | awk '{print $1}'`
  PKGGROSSE_CALC=`bc <<< "scale=3; ${PKGGROSSE_FILE}/1000"`
  printf '%s' "\
Estimated total disk space: ${DSKGROSSE}MB
Estimated used space: ${DSKVERF}MB
Estimated space available: ${BENUTZT}MB
Estimated space to be consumed (build files): ${PKGGROSSE_CALC}MB
Estimated free space: `bc <<< "scale=3; ${DSKVERF} - ${PKGGROSSE_CALC}"`MB
"
  return 0
}

CheckRawPackage(){
  if [ "${RAW_PKG}" = '1' ]; then 
    # For uncompress
    PKGNM="${I}" # I've called it "I" because i couldn't think of a name, sorry.
    BASENAME=`basename ${I}`
    PKG_FILENAME=${I%%$PKG_FORMT}
    alias extractpkg="/usr/bin/7z x ${I} -o${SRCDIR}/uncompressed-${PKG_FILENAME}"
    EXTR_MSG="Extracting ${BASENAME}"
    # Source pkginfo
    alias sourcepkginfo=". ${SRCDIR}/uncompressed-${PKG_FILENAME}/pkginfo"
  else 
    # Run the DownloadPackage() function
    DownloadPackage
    PKG_FILENAME=`getPKG_FILENAME`
    # Source pkginfo
    alias sourcepkginfo=". ${SRCDIR}/uncompressed-${PKG_FILENAME}/pkginfo"
    # For uncompress
    alias extractpkg="/usr/bin/7z x ${SRCDIR}/${PKG_FILENAME}${PKG_FORMT} -o${SRCDIR}/uncompressed-${PKG_FILENAME} -bb1" # For uncompressing downloaded packages, local pkginfo needs to be sourcered first.
    EXTR_MSG="Extracting ${PKG_FILENAME}${PKG_FORMT}"
  fi
}

CheckDependencies(){
  # I hope this don't become a non-intentional fork bomb, like recursive GNU auto*hell scripts.
  set -a dependency_array
  dependencies_index="${SRCDIR}/uncompressed-${PKG_FILENAME}/install/depend"
  POINT=0
  # Thanks Benjie from StackOverflow for this beautiful sed command line that i've slightly changed to remove comments.
  for DEP in "`sed -e '/#/d' -e ':a' -e 'N' -e '$!ba' -e 's/\n/ /g' "${dependencies_index}"`"; do
    if [ "`grep -Fxq "${DEP}" "${CONTENTS}"`" ]; then
      printf '%s\n' "${DEP} is O.K."
    else
      dependency_array[${POINT}]=${DEP}
      POINT=$(( $POINT + 1 )) 
    fi
  done
  [ -z "${dependency_array[@]}" ] && { printf '%b\n' "${YELLOW}WARNING$END: ${DEP} isn't installed. Installing it now." ; InstallPackage ${dependency_array[@]}} || printf '%s\n' 'No dependencies to install, we'\''re good to go.'
  unset POINT dependency_array
  return 0
}

# Sure i am, dad.

DownwloadPackage(){
  if [ "${SYNC_TYPE}" = 'bittorrent' ]; then
    TORRENT="${PKGNM}"
    sourcelocalpkginfo
    pico-torrent -s -f "${PKGDIR}"/"${TORRENT}"/pkgp2p -d "${SRCDIR}"
  elif [ "${SYNC_TYPE}" = 'http' ] || [ "${SYNC_TYPE}" = 'ftp' ]; then
    sourcelocalpkginfo
    chdir "${SRCDIR}" && { curl -O -# "`cat ${PKGDIR}/${PKG}/pkglink`" ; chdir -;}
  else
    printf '%b' "${RED}ERROR$END: ${YELLOW}SYNC_TYPE$END not set at /etc/make.cfg.\nRead manual pages for more information. Exit code is 1."
    exit 1
 fi
}

Uncompress(){
  printf '%s' "${EXTR_MSG}"
  txtwait &
  extractpkg
  tar -vxf "${SRCDIR}"/uncompressed-"${PKG_FILENAME}"/src.tar && rm -v "${SRCDIR}"/uncompressed-"${PKG_FILENAME}"/src.tar
  return 0
}

Build(){
  # Scripts for building the package shall be minimal and pure POSIX
  /bin/sh "${SRCDIR}"/uncompressed-"${PKG_FILENAME}"/install/checkinstall
  /bin/sh "${SRCDIR}"/uncompressed-"${PKG_FILENAME}"/install/makebuild
  return 0
}

GenerateLocalpkgmap(){
cat > `printf '%s' "${INSTDIR}"`/OTTO"${PKG}"/pkgmap <<EOD
`cat "${SRCDIR}"/uncompressed-"${PKG_FILENAME}"/pkgmap`
EOD
  return 0
} # This will load directory variables (ex: low /usr or high /usr?) for a specific install, in theory.

GenerateLocalpkginfo(){
cat > "${INSTDIR}"/OTTO"${PKG}"/pkginfo <<EOD
`cat "${SRCDIR}"/uncompressed-"${PKG_FILENAME}"/pkginfo`
printf '%s\n' "INSTDATE='`/usr/bin/date '+%b %e %Y %H:%M:%S'`'"
EOD
  return 0
}

InstallPackage(){
  printf "Packages to install: ${#@}\n" 
  for (( i = 0; i < "${#@}"; i++))
  {
    CheckRawPackage
    Uncompress
    sourcepkginfo # Source package extracted pkginfo (i know, it's messy but it works in theory)
    export PKGNM="${CATEGORY}/${PKG}"
    CheckDependencies
    CheckDisk
    Build
    mkdir ${INSTDIR}/OTTO"${PKG}"
    GenerateLocalpkgmap
    GenerateLocalpkginfo
    printf '%s\n' "${PKGNM}-${VERSION}" >> ${CONTENTS}
  }
  return 0
}

RemovePackage(){
  for (( i=0; i < "${#@}"; i++ ))
  { 
    PKGNM=${@[${I}]}
    printf '%s' "Removing ${CATEGORY}/${PKG}"
    txtwait &
    < /var/otto/installed/pkg/OTTO"$PKG"/pkgmap /usr/bin/xargs rm -rfv  # Wait, do this work? Really awesome to see that i didn't need that cat.
    /bin/rm -rfv /var/otto/installed/pkg/OTTO"${PKG}"
    /bin/sed -i "/${PKGNM}/d" ${CONTENTS}
  }
  return 0
}

fn_Sync(){
  printf '%s\n' "Refreshing packages metadata \(${mirror_basename}\)..."
  curl -s "${mirror_basename}"/SERVERINFO.txt "${mirror_basename}"/SERVERRULES.txt
  { chdir "${SRCDIR}" && { curl -O -# "${MIRROR}"/lastest_meta"${INDEXFILE}" ; chdir "${PKGDIR}" && 7z x ${SRCDIR}/lastest_meta"${INDEXFILE}" -o"${PKGDIR}" -bb1} }
  printf '%s\n' "Package index updated \(`date '+%Y.%m.%d @ %H:%M:%S'`\)."
}

Update(){ 
  local index_package_source="`. ${PKGDIR}/${PKGNM}/pkginfo`"
  local index_package_version="`printf '%s'  "${VERSION}" | tr -d '.'`"
  local installed_package_version="`grep -oP ${PKGNM}'-[0-9]+\.[0-9]+' ${CONTENTS} | tr -d '.' | tr -dc '0-9'`"
  fn_Sync
  for PKGNM in "${@}"; do
    printf '%s\n' "Checking updates for ${PKGNM}."
    if [ "${index_package_version}" \> "${installed_package_version}" ]; then
      printf '%s' "Updating ${PKGNM} \(${installed_package_version} -> ${index_package_version}\)"
      txtwait
      sed -i "/${PKGNM}-${installed_package_version}/d" "${CONTENTS}"
      rm -rf /var/otto/installed/pkg/OTTO"${PKG}"
      InstallPackage "${PKGNM}"
      printf '%s\n' "Updated ${PKGNM} succesfully."
    elif [ "${index_package_version}" \< "${installed_package_version}" ]; then
      echo "${YELLOW}WARNING$END: ${PKGNM}'s index files are from an older version than installed one, downgrading."
      printf '%s' "Downgrading ${PKGNM} \(${installed_package_version} -> ${index_package_version}\)"
      txtwait
      sed -i "/${PKGNM}-${installed_package_version}/d" "${CONTENTS}"
      rm -rf /var/otto/installed/pkg/OTTO"${PKG}"
      InstallPackage "${PKGNM}"
      printf '%s\n' "Downgraded ${PKGNM}."
    else
      printf '%s\n' "${PKGNM} is up to date."
    fi
  done
  return 0
}

MakePackage(){
  # This first implementation will be only for pure source code.
  # I need to make it more "binary-packaging-friendly".
  export makepkg_dir="${HOME}/packaging/${1}"
  export DESTDIR="${makepkg_dir}/fakeroot"
  printf '%s\n' "Creating package skeleton for ${1}."
  mkdir -v "${makepkg_dir}"
  mkdir -v "${makepkg_dir}"/install
  mkdir -v "${makepkg_dir}"/src
  mkdir -v "${makepkg_dir}"/tmpinst
  mkdir -v "${DESTDIR}"
  cat > ${makepkg_dir}/pkginfo <<EOD
PKG="${1}"
NAME="${1} X.Y.Z '<CPU> <ARCH>bit' Copacabana"
VERSION='X.Y.Z'
PSTAMP=`date '+%Y.%m.%d'`
VENDOR=''
EMAIL=''
DESC=''
ARCH=''
CATEGORY=''
CLASSES=''
BASEDIR='/'
DIRSTATES='1 2'
EOD
  > ${makepkg_dir}/pkgmap
  # Where are we dropping, boys?
  printf '%s\n' "Time to move the final package files (binaries, scripts etc, not the source code) to the fakeroot (${DESTDIR}), it will be the base to pkgmap(4).\nWhen you'\''re done, just exit the drop-shell session."
  printf '%s\n' "Dropping to an UNIX Shell (${SHELL})"
  /bin/sh -c "cd ${makepkg_dir} ; /usr/bin/env ${SHELL}"
  # Edit pkginfo
  editor "${makepkg_dir}"/pkginfo
  # Map it with fd(1)
  fd . ${DESTDIR} > "${makepkg_dir}"/pkgmap
  # Change directories to variables in pkgmap (after mapping the compiled package with fd(1))
  sed -e 's/\/usr/${USRDIR}/g' -e 's/\/bin/${BINDIR}/g' -e 's/\/etc/${ETC}/g' "${makepkg_dir}"/pkgmap > /tmp/pkgmap_"${1}" && mv /tmp/pkgmap_"${1}" "${makepkg_dir}"/pkgmap
  exit 0
}

ListPackages(){
  if [ -f "${CONTENTS}" ]; then
    pcat "${CONTENTS}"
    lines "${CONTENTS}"
    exit 0
  else
    printf "${RED}ERROR:$END package list not found! This isn't a good thing...\a\n"
    exit 140
  fi
}

PackageInfo(){
  . /var/otto/installed/pkg/OTTO"${PKG}"/pkginfo
  local FILES="`lines /var/otto/installed/pkg/OTTO"${PKG}"/pkgmap`"
  printf '%s' "
PACKAGE: ${PKG}
DESCRIPTION: ${DESC}  
CATEGORY: ${CATEGORY}
ARCH: ${ARCH}
VERSION: ${VERSION}
BASEDIR:  ${BASEDIR}
PRODUCTION STAMP:  ${PSTAMP}
INSTALL DATE: ${INSTDATE}
FILES AND FOLDERS: ${FILES} 
"
  return 0
}

ProgramInfo(){ 
  printf '%s' "\
${BOLD}Otto, eine Paketverwaltungs-Toolchain.$END
Ausgabe: ${ausgabe}
Paketformat: ${PKG_FORMT}
Betriebssystem: ${HOST_OS}
HTTP-Spiegel: ${mirror_basename}

Copyright (c) MMXX Luiz Antonio Rangel et Project Pindorama.
See CONTRIBUTORS.txt file for more.

✠ GOTT MIT UNS ✠
"
  exit 0
}

Help(){
  printf "\
[USAGE]: otto -[i|v|r|d|b|u] <category>/<package> | -dr <package filename>${PKG_FORMT} | -m <package name> | -[N|H|I|l|f|S|?]
For more information about what each one of these flags mean, type 'man otto' in your Shell."
  exit 0
}

fn_FindPackage(){

}

fn_main(){
OPTPARAMS="NHiIlfvrd:b:u:m:S" 
while getopts "${OPTPARAMS}" OPT; do
  case "${OPT}" in
    "H") Help ;;
    "i") PackageInfo ;;
    "I") ProgramInfo ;;
    "f") fn_FindPackage ;;
    "v") export VERBOSE=1 ;;
    "r") export RAW_PKG=1 ;;
    "d") Checkroot && InstallPackage "${OPTARG}" ;;
    "b") CheckParameters "${OPTARG}" && Checkroot && RemovePackage "${OPTARG}" ;;
    "S") Checkroot && fn_Sync ;;
    "u") Checkroot && Update "${OPTARG}" ;;
    "m") MakePackage "${OPTARG}" ;;
    "l") ListPackages ;;
    "N") CheckNetwork ;;
    "?") Help ;;
  esac
done
}
fn_main ${@}
