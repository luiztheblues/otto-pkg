#!/usr/bin/env ksh 
# shellcheck disable=SC1090,SC1091,SC2006,SC2059

# Otto-PKG - Ein Ports-ähnlicher Paketmanager.

# Caldera License (a.k.a 4-Clause BSD).
# Copyright (c) MMXX, Luiz Antônio Rangel, Caio Novais et Projeto Pindorama;
# Read LICENSE.txt @ master branch root (GitHub) for the complete license.

# Include Files
. /usr/etc/make.cfg
. /usr/lib/otto/colors.shi
. /usr/lib/otto/blink.shi
. /usr/lib/otto/txtwait.shi
. /usr/lib/otto/posix-alt.shi

# Program Specifications
binary_name="`basename ${0}`"
ausgabe='0.8'
PKG_FORMT='.psl'
HOST_OS="`uname -s`"
LANG='POSIX'
LC_ALL="${LANG}"
mirror_basename=${${MIRROR#*//}%%/*}
export binary_name ausgabe PKG_FORMT PKG_COMPSS HOST_OS LANG LC_ALL mirror_basename;

# Export alias
alias chdir='cd';

# ARE YA CHECKING SON?

fn_CheckNetwork(){
  # ${MIRROR} is applyed only in packages officially created, unofficial packages probabily will use some custom domain.
  printf '%s' 'Checking network connection';
  txtwait &
  if [ `printf '%s\n\n' "GET ${mirror_basename} HTTP/1.0" | netcat "${mirror_basename}" 80 > /dev/null 2>&1` ]; then
    printOK 'Mirror is up and running.';
    return 0;
  else
    printERR 'Network is unreachable or server is down. Exit code is 11.';
    exit 11;
  fi
}

fn_CheckParameters(){
  if [ -z "${OPTARG}" ]; then
    printERR 'Insufficient parameters. Exit code is 1.';
    exit 1;
  fi
}

fn_CheckDisk(){
  BENUTZT=`df -m / | tail -1 | grep '[0-9]' | awk '{print $3}'`;
  DSKVERF=`df -m / | tail -1 | grep '[0-9]' | awk '{print $4}'`;
  DSKGROSSE=$[${BENUTZT} + ${DSKVERF}];
  PKGGROSSE_FILE=`du -sk <pacote> | awk '{print $1}'`; # Tenho que botar o pacote .psl depois aqui.
  PKGGROSSE_CALC=`bc <<< "scale=3; ${PKGGROSSE_FILE}/1000"`;
  printf '%s' "\
Estimated total disk space: ${DSKGROSSE}MB
Estimated used space: ${DSKVERF}MB
Estimated space available: ${BENUTZT}MB
Estimated space to be consumed (build files): ${PKGGROSSE_CALC}MB
Estimated free space: `bc <<< "scale=3; ${DSKVERF} - ${PKGGROSSE_CALC}"`MB
";
  return 0;
}

fn_CheckDependencies(){
  # I hope this don't become a non-intentional fork bomb, like recursive GNU auto*hell scripts.
  set -a dependency_array;
  local dependencies_index=(${@});
  local N_dependencies_index=`n ${dependencies_index[@]}`;
  local POINT='0';
  for (( i=0; i < ${N_dependencies_index}; i++ )){
    if [ "`grep -Fx "${DEP}" "${CONTENTS}" &> /dev/null`" ]; then
      printOK "${DEP} is installed.";
    else
      dependency_array[${POINT}]=${DEP};
      POINT=$(( $POINT + 1 ));
    fi
  }
  if [ -z "${dependency_array[@]}" ]; then
    printWAR 'Installing remaining dependencies now.'; 
    fn_InstallPackage "${dependency_array[@]}";
  else
    printOK 'No extra dependencies to install.';
  fi
  unset dependencies_index N_dependencies_index dependency_array POINT;
  return 0
}

# Sure i am, dad.

fn_AutoClean(){
  local TOCLEAN=(${TMPDIR} ${PKGDIR});
  local N_TOCLEAN=`n ${TOCLEAN[@]}`;
  for (( i=0; i < ${N_TOCLEAN}; i++ )){
    printWAR "Cleaning ${TOCLEAN[${i}]}.";
    find ${TOCLEAN[${i}]} -exec rm -rvf {} \;
  }
  return 0;
}

fn_DownloadPackage(){
  return 0
}

fn_Build(){
  return 0
}

fn_InstallPackage(){
  local N_STDIN=`n ${@}`
  printf "Packages to install: ${N_STDIN}\n"; 
  for (( i = 0; i < "${N_STDIN}"; i++)){
    local PKGNM=${@[${i}]};
    PKGBUILD_DIR=`find ${DBDIR} -name "${PKGNM}"`;
    . ${PKGBUILD_DIR}/pkginfo
    fn_CheckDependencies ${REQUIRES} &&
    fn_CheckDisk &&
    fn_Build &&
  }
  return 0;
}

fn_RemovePackage(){
  local N_STDIN=`n ${@}`
  printf "Packages to remove: ${N_STDIN}\n"; 
  /sbin/removepkg ${@}; 
  return 0;
}

fn_Sync(){
  printf '%s\n' "Refreshing packages metadata \(${mirror_basename}\)..." ;
  if [ ${SYNC_TYPE} = HTTP ]; then
    curl -s "${MIRROR}"/info.cgi 2> /dev/null || printWAR 'No server information provided.';
    curl -# "${MIRROR}"/copaports-${VERSION}.txz --output - | xz -cd - | tar -xvf - -C ${DBDIR};
  elif [ ${SYNC_TYPE} = 'GIT' ];
     git clone -v "${MIRROR}" -b "${VERSION}" "${DBDIR}"; 
  fi
  printOK "Package index updated \(`date '+%Y.%m.%d @ %H:%M:%S'`\).";
  return 0;
}

fn_Update(){
  return 0; # TODO
}

fn_ListPackages(){
  if [ -f "${CONTENTS}" ]; then
    pcat "${CONTENTS}"
    lines "${CONTENTS}"
    exit 0
  else
    printERR 'Package list not found. Exit code is 140.'
    exit 140
  fi
}

fn_PackageInfo(){
  . /var/otto/installed/pkg/OTTO"${PKG}"/pkginfo
  printf '%s' "
PACKAGE: ${PKG}
DESCRIPTION: ${DESC}  
CATEGORY: ${CATEGORY}
ARCH: ${ARCH}
VERSION: ${VERSION}
BASEDIR:  ${BASEDIR}
PRODUCTION STAMP:  ${PSTAMP}
INSTALL DATE: ${INSTDATE}
FILES AND FOLDERS: ${FILES} 
"
  return 0
}

fn_ProgramInfo(){ 
  printf '%s' "\
${BOLD}Otto, eine Paketverwaltungs-Toolchain.$END
Ausgabe: ${ausgabe}
Paketformat: ${PKG_FORMT}
Betriebssystem: ${HOST_OS}
WEB-Spiegel: ${mirror_basename}

Copyright (c) MMXX Luiz Antonio Rangel, Caio Novais et Project Pindorama.
See the CONTRIBUTORS file for more.

✠ GOTT MIT UNS ✠
"
  exit 0
}

fn_Help(){
  printf "\
[USAGE]: otto -[i|v|r|d|b|u] <category>/<package> | package | -[N|H|I|l|f|S|?]
For more information about what each one of these flags mean, type 'man otto' in your Shell."
  exit 0
}

findpkg(){
  find ${DBDIR} -name "${@}";
  return 0;
}

fn_main(){
  OPTPARAMS="NHiIlfvd:b:u:S" 
  while getopts "${OPTPARAMS}" OPT; do
    case "${OPT}" in
      "H") fn_Help ;;
      "i") fn_PackageInfo ;;
      "f") findpkg ;;
      "v") export VERBOSE=1 ;;
      "d") fn_CheckParameters "${OPTARG}" && fn_InstallPackage "${OPTARG}" ;;
      "b") fn_CheckParameters "${OPTARG}" && fn_RemovePackage "${OPTARG}" ;;
      "S") fn_Checkroot && fn_Sync ;;
      "u") fn_Checkroot && fn_Update "${OPTARG}" ;;
      "l") fn_ListPackages ;;
      "N") fn_CheckNetwork ;;
      "?") fn_Help ;;
    esac
  done
}

fn_main ${@}
