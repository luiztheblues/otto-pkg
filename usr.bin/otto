#!/usr/bin/env ksh 
# Ok, i will remember to patch it later.
# shellcheck disable=SC1090,SC1091,SC2006,SC2059

# Otto-PKG - Ein Paketmanager, der Pakete über BitTorrent (und nun HTTP) herunterlädt.

# Caldera License (a.k.a 4-Clause BSD).
# Copyright (c) MMXX, Luiz Antônio Rangel et Projeto Pindorama;
# Read LICENSE.txt @ master branch root (GitHub) for the complete license.

############## Include Files ##############
. /etc/make.cfg
. /usr/lib/otto/colors.shi
. /usr/lib/otto/blink.shi
. /usr/lib/otto/txtwait.shi
. /usr/lib/otto/posix-alt.shi
##############     END       ##############

############# Program Specifications ######
# Program Name: Otto
export ausgabe='0.7'
export PKG_FORMT='.psl'
export INDEXFILE='.otidx'
export PKG_COMPSS='7z'
export HOST_OS="`uname -s`"
##############     END       ##############

############# Export C locale #############
export LANG='C'
export LC_ALL="${LANG}"
##############     END       ##############

############# Export alias ##########
alias chdir='cd' # This shall be commented when /bin/sh already has a native "chdir" command/system call.
alias editor="/usr/bin/env ${EDITOR}"
alias sourcelocalpkginfo=". "${PKGDIR}"/"${TORRENT}"/pkginfo"
##############     END       ##############

############## Global Variables #
[ -z "${DROP_SHELL}" ] && export SHELL='ksh' || export SHELL="${DROP_SHELL}"
export mirror_basename=${${MIRROR#*//}%%/*}
##############     END       ##############

# Subshells
alias getPKG_FILENAME="printf '%s' "${NAME}" | tr ' ' '.'"
# END

# Script Functions

# ARE YA CHECKING SON?
Checkroot(){
  if [ "`whoami`" != 'root' ] && [ "`whoami`" != 'toor' ]; then
    printf '%b' "${YELLOW}WARNING$END: It looks like you are not logged into toor nor root user...\nWould you like to install the program on the highest userland layer (${HIUSR}) instead of installing directly on the root of the system?\n${YELLOW}WARNING$END: Some packages ${BOLD}cannot$END be installed on the highest userland layer under any circunstances.\nRegarding the first (and only) question: [Y,N]? "
    read -r ANTWORTEN
    if grep -iq '^y' <<< "$ANTWORTEN"; then
      export USRDIR="${HIUSR}"
      export USRBIN="${HIUSRBIN}"
      export ETC="${HIETC}"
      export SRCDIR="${HISRCDIR}"
      export DIRISTATE=2
    else
      printf '%s\n' 'Alright so, exiting...'
      exit 130
    fi
  else
    export USRDIR="${LOUSR}"
    export USRBIN="${LOUSRBIN}"
    export ETC="${LOETC}"
    export SRCDIR="${LOSRCDIR}"
    export DIRISTATE='1'
  fi
}

CheckNetwork(){
  # $MIRROR is applyed only in packages officially created, unofficial packages probabily will use some custom domain.
  printf '%s' 'Checking network connection'
  txtwait
  if [ `printf "GET ${mirror_basename} HTTP/1.0\n\n" | netcat "${mirror_basename}" 80 > /dev/null 2>&1` ]; then
    printf '%b' "[ ${GREEN}O.K.$END ]\n"
  else
    printf '%b' "[ ${RED}FAILED$END ]\n"
    printf '%b\n' "${RED}ERROR$END: Apparently, this box isn't connected to the World Wide Web.\a\nIf you don't have a internet connection, try to download the raw package (a ${YELLOW}${PKG_FORMT}$END which contains everything necessary to install the program), save it in a diskette/CD/SDCard/USB and install it using ${YELLOW}'otto -dr'$END.\nIf you expected to have networking on this box, do some checks.\nCheck if the network daemon is running, if the drivers are enabled on the Kernel and if the physical devices are even working/turned on.\n"
    return 11
  fi
}

CheckParameters(){
  if [ -z "${OPTARG}" ]; then
    printf '%s\n' "${RED}ERROR$END: Insufficient parameters."
    exit 1
  fi
}

CheckDisk(){
  BENUTZT=`df -m / | tail -1 | grep '[0-9]' | awk '{print $3}'`
  DSKVERF=`df -m / | tail -1 | grep '[0-9]' | awk '{print $4}'`
  DSKGROSSE=$[${BENUTZT} + ${DSKVERF}]
  PKGGROSSE_FILE=`du -sk "${SRCDIR}"/uncompressed-"${PKG_FILENAME}"/src.tar | awk '{print $1}'`
  PKGGROSSE_CALC=`bc <<< "scale=3; ${PKGGROSSE_FILE}/1000"`
  printf '%s' "\
Estimated total disk space: ${DSKGROSSE}MB
Estimated used space: ${DSKVERF}MB
Estimated space available: ${BENUTZT}MB
Estimated space to be consumed (build files): ${PKGGROSSE_CALC}MB
Estimated free space: `bc <<< "scale=3; ${DSKVERF} - ${PKGGROSSE_CALC}"`MB
"
  return 0
}

CheckRawPackage(){
  if [ "${RAW_PKG}" = '1' ]; then 
    # For uncompress
    PKGNM="${I}" # I've called it "I" because i couldn't think of a name, sorry.
    BASENAME=`basename $I`
    PKG_FILENAME=${I%%$PKG_FORMT}
    alias extractpkg="/usr/bin/7z x ${I} -o${SRCDIR}/uncompressed-${PKG_FILENAME}"
    EXTR_MSG="Extracting ${BASENAME}"
    # Source pkginfo
    alias sourcepkginfo=". ${SRCDIR}/uncompressed-${PKG_FILENAME}/pkginfo"
  else 
    # Run the DownloadPackage() function
    DownloadPackage
    PKG_FILENAME=`getPKG_FILENAME`
    # Source pkginfo
    alias sourcepkginfo=". ${SRCDIR}/uncompressed-${PKG_FILENAME}/pkginfo"
    # For uncompress
    alias extractpkg="/usr/bin/7z x ${SRCDIR}/${PKG_FILENAME}${PKG_FORMT} -o${SRCDIR}/uncompressed-${PKG_FILENAME} -bb1" # For uncompressing downloaded packages, local pkginfo needs to be sourcered first.
    EXTR_MSG="Extracting ${PKG_FILENAME}${PKG_FORMT}"
  fi
}

CheckDependencies(){
  # I hope this don't become a non-intentional fork bomb, like recursive GNU auto*hell scripts.
  set -a dependency_array
  dependencies_index="${SRCDIR}/uncompressed-${PKG_FILENAME}/install/depend"
  POINT=0
  # Thanks Benjie from StackOverflow for this beautiful sed command line that i've slightly changed to remove comments.
  for DEP in "`sed -e '/#/d' -e ':a' -e 'N' -e '$!ba' -e 's/\n/ /g' "${dependencies_index}"`"; do
    if [ "`grep -Fxq "${DEP}" "${CONTENTS}"`" ]; then
      printf '%s\n' "${DEP} is O.K."
    else
      dependency_array[${POINT}]=${DEP}
      POINT=$(( $POINT + 1 )) 
    fi
  done
  [ -z "${dependency_array[@]}" ] && { printf '%b\n' "${YELLOW}WARNING$END: ${DEP} isn't installed. Installing it now." ; InstallPackage ${dependency_array[@]}} || printf '%s\n' 'No dependencies to install, we'\''re good to go.'
  unset POINT dependency_array
  return 0
}

# Sure i am, dad.

DownwloadPackage(){
  if [ "${SYNC_TYPE}" = 'bittorrent' ]; then
    TORRENT="${PKGNM}"
    sourcelocalpkginfo
    pico-torrent -s -f "${PKGDIR}"/"${TORRENT}"/pkgp2p -d "${SRCDIR}"
  elif [ "${SYNC_TYPE}" = 'http' ] || [ "${SYNC_TYPE}" = 'ftp' ]; then
    sourcelocalpkginfo
    chdir "${SRCDIR}" && { curl -O -# "`cat ${PKGDIR}/${PKG}/pkglink`" ; chdir -;}
  else
    printf "${RED}ERROR$END: ${YELLOW}SYNC_TYPE$END not set @ /etc/make.cfg.\nAre you trying to install a local package? Use ${YELLOW}-r$END with ${YELLOW}-d$END"
    exit 1
 fi
}

Uncompress(){
  printf '%s' "${EXTR_MSG}"
  txtwait &
  extractpkg
  tar -vxf "${SRCDIR}"/uncompressed-"${PKG_FILENAME}"/src.tar && rm -v "${SRCDIR}"/uncompressed-"${PKG_FILENAME}"/src.tar
  return 0
}

Build(){
  # Scripts for building the package shall be minimal and pure POSIX
  /bin/sh "${SRCDIR}"/uncompressed-"${PKG_FILENAME}"/install/checkinstall
  /bin/sh "${SRCDIR}"/uncompressed-"${PKG_FILENAME}"/install/makebuild
  return 0
}

GenerateLocalpkgmap(){
cat > /var/otto/installed/pkg/OTTO"${PKG}"/pkgmap <<EOD
`cat "${SRCDIR}"/uncompressed-"${PKG_FILENAME}"/pkgmap`
EOD
  return 0
} # This will load directory variables (ex: low /usr or high /usr?) for a specific install, in theory.

GenerateLocalpkginfo(){
cat > /var/otto/installed/pkg/OTTO"${PKG}"/pkginfo <<EOD
`cat "${SRCDIR}"/uncompressed-"${PKG_FILENAME}"/pkginfo`
printf '%s\n' "INSTDATE='`/usr/bin/date '+%b %e %Y %H:%M:%S'`'"
EOD
  return 0
}

AutoClean(){
  if [ "${AUTOCLEAN}" = 'YES' ]; then
    printf '%s\n' "Cleaning "${CATEGORY}"/"${PKG}" sources." ; rm -rvf "${SRCDIR}"/"uncompressed-*" && rm -vf "${SRCDIR}"/*"${PKG_FORMT}"
  else
    printf '%b\n' "${YELLOW}WARNING$END: Autocleaning is disabled, trash will stay in the system until someone with the needed permissions deletes them."
  fi
  return 0
}

InstallPackage(){
  printf "Packages to install: ${#@}\n" 
  for PKGNM in "${@}"; do
    CheckRawPackage
    Uncompress
    sourcepkginfo # Source package extracted pkginfo (i know, it's messy but it works in theory)
    export PKGNM="${CATEGORY}/${PKG}"
    CheckDependencies
    CheckDisk
    Build
    mkdir /var/otto/installed/pkg/OTTO"${PKG}"
    GenerateLocalpkgmap
    GenerateLocalpkginfo
    printf '%s\n' "${PKGNM}-${VERSION}" >> ${CONTENTS}
  done
  AutoClean
  return 0
}

RemovePackage(){
  for PKGNM in "${@}"; do 
    printf '%s' "Removing ${CATEGORY}/${PKG}"
    txtwait &
    < /var/otto/installed/pkg/OTTO"$PKG"/pkgmap /usr/bin/xargs rm -rfv  # Wait, do this work? Really awesome to see that i didn't need that cat.
    /bin/rm -rfv /var/otto/installed/pkg/OTTO"${PKG}"
    /bin/sed -i "/${PKGNM}/d" ${CONTENTS}
  done
  return 0
}

fn_Sync(){
  printf '%s\n' "Refreshing packages metadata \(${mirror_basename}\)..."
  curl -s "${MIRROR}"/SERVERINFO.txt "${MIRROR}"/SERVERRULES.txt
  { chdir "${SRCDIR}" && { curl -O -# "${MIRROR}"/lastest_meta"${INDEXFILE}" ; chdir "${PKGDIR}" && 7z x ${SRCDIR}/lastest_meta"${INDEXFILE}" -o"${PKGDIR}" -bb1} }
  printf '%s\n' "Package index updated \(`date '+%Y.%m.%d @ %H:%M:%S'`\)."
}

Update(){ 
  local index_package_source="`. ${PKGDIR}/${PKGNM}/pkginfo`"
  local index_package_version="`printf '%s'  "${VERSION}" | tr -d '.'`"
  local installed_package_version="`grep -oP ${PKGNM}'-[0-9]+\.[0-9]+' ${CONTENTS} | tr -d '.' | tr -dc '0-9'`"
  fn_Sync
  for PKGNM in "${@}"; do
    printf '%s\n' "Checking updates for ${PKGNM}."
    if [ "${index_package_version}" \> "${installed_package_version}" ]; then
      printf '%s' "Updating ${PKGNM} \(${installed_package_version} -> ${index_package_version}\)"
      txtwait
      sed -i "/${PKGNM}-${installed_package_version}/d" "${CONTENTS}"
      rm -rf /var/otto/installed/pkg/OTTO"${PKG}"
      InstallPackage "${PKGNM}"
      printf '%s\n' "Updated ${PKGNM} succesfully."
    elif [ "${index_package_version}" \< "${installed_package_version}" ]; then
      echo "${YELLOW}WARNING$END: ${PKGNM}'s index files are from an older version than installed one, downgrading."
      printf '%s' "Downgrading ${PKGNM} \(${installed_package_version} -> ${index_package_version}\)"
      txtwait
      sed -i "/${PKGNM}-${installed_package_version}/d" "${CONTENTS}"
      rm -rf /var/otto/installed/pkg/OTTO"${PKG}"
      InstallPackage "${PKGNM}"
      printf '%s\n' "Downgraded ${PKGNM}."
    else
      printf '%s\n' "${PKGNM} is up to date."
    fi
  done
  return 0
}

MakePackage(){
  # This first implementation will be only for pure source code.
  # I need to make it more "binary-packaging-friendly".
  export makepkg_dir="${HOME}/packaging/${1}"
  export DESTDIR="${makepkg_dir}/fakeroot"
  printf '%s\n' "Creating package skeleton for ${1}."
  mkdir -v "${makepkg_dir}"
  mkdir -v "${makepkg_dir}"/install
  mkdir -v "${makepkg_dir}"/src
  mkdir -v "${makepkg_dir}"/tmpinst
  mkdir -v "${DESTDIR}"
  cat > ${makepkg_dir}/pkginfo <<EOD
PKG="${1}"
NAME="${1} X.Y.Z '<CPU> <ARCH>bit' Copacabana"
VERSION='X.Y.Z'
PSTAMP=`date '+%Y.%m.%d'`
VENDOR=''
EMAIL=''
DESC=''
ARCH=''
CATEGORY=''
CLASSES=''
BASEDIR='/'
DIRSTATES='1 2'
EOD
  > ${makepkg_dir}/pkgmap
  # Where are we dropping, boys?
  printf '%s\n' "Time to move the final package files (binaries, scripts etc, not the source code) to the fakeroot (${DESTDIR}), it will be the base to pkgmap(4).\nWhen you'\''re done, just exit the drop-shell session."
  printf '%s\n' "Dropping to an UNIX Shell (${SHELL})"
  /bin/sh -c "cd ${makepkg_dir} ; /usr/bin/env ${SHELL}"
  # Edit pkginfo
  editor "${makepkg_dir}"/pkginfo
  # Map it with fd(1)
  fd . ${DESTDIR} > "${makepkg_dir}"/pkgmap
  # Change directories to variables in pkgmap (after mapping the compiled package with fd(1))
  sed -e 's/\/usr/${USRDIR}/g' -e 's/\/bin/${BINDIR}/g' -e 's/\/etc/${ETC}/g' "${makepkg_dir}"/pkgmap > /tmp/pkgmap_"${1}" && mv /tmp/pkgmap_"${1}" "${makepkg_dir}"/pkgmap
  exit 0
}

ListPackages(){
  if [ -f "${CONTENTS}" ]; then
    pcat "${CONTENTS}"
    lines "${CONTENTS}"
    exit 0
  else
    printf "${RED}ERROR:$END package list not found! This isn't a good thing...\a\n"
    exit 140
  fi
}

PackageInfo(){
  . /var/otto/installed/pkg/OTTO"${PKG}"/pkginfo
  local FILES="`lines /var/otto/installed/pkg/OTTO"${PKG}"/pkgmap`"
  printf '%s' "
PACKAGE: ${PKG}
DESCRIPTION: ${DESC}  
CATEGORY: ${CATEGORY}
ARCH: ${ARCH}
VERSION: ${VERSION}
BASEDIR:  ${BASEDIR}
PRODUCTION STAMP:  ${PSTAMP}
INSTALL DATE: ${INSTDATE}
FILES AND FOLDERS: ${FILES} 
"
  return 0
}

ProgramInfo(){ 
  printf '%s' "\
${BOLD}Otto, eine Paketverwaltungs-Toolchain.$END
Ausgabe: ${ausgabe}
Paketformat: ${PKG_FORMT}
Betriebssystem: ${HOST_OS}
HTTP-Spiegel: ${mirror_basename}

Copyright (c) MMXX Luiz Antonio Rangel et Project Pindorama.
See CONTRIBUTORS.txt file for more.

✠ GOTT MIT UNS ✠
"
  exit 0
}

Help(){
  printf "\
[USAGE]: otto -[i|v|r|d|b|u] <category>/<package> | -dr <package filename>${PKG_FORMT} | -m <package name> | -[N|H|I|l|f|S|?]
For more information about what each one of these flags mean, type 'man otto' in your Shell."
  exit 0
}

#find(){

#}
# END



# CASE AND GETOPT
OPTPARAMS="NHiIlfvrd:b:u:m:S" 
while getopts "${OPTPARAMS}" OPT; do
  case "${OPT}" in
    "H") Help ;;
    "i") PackageInfo ;;
    "I") ProgramInfo ;;
    "f") find ;;
    "v") export VERBOSE=1 ;;
    "r") export RAW_PKG=1 ;;
    "d") Checkroot && InstallPackage "${OPTARG}" ;;
    "b") CheckParameters "${OPTARG}" && Checkroot && RemovePackage "${OPTARG}" ;;
    "S") Checkroot && fn_Sync ;;
    "u") Checkroot && Update "${OPTARG}" ;;
    "m") MakePackage "${OPTARG}" ;;
    "l") ListPackages ;;
    "N") CheckNetwork ;;
    "?") Help ;;
  esac
done
# END
