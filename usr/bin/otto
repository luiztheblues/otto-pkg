#!/usr/bin/env ksh 
# Do arrays actually work on Ksh? I think that array bug is a Public Domain Ksh fault, may i try it on ksh93 later.
# Ok, i will remember to patch it later.
# shellcheck disable=SC1090,SC1091,SC2006,SC2059

# Otto-PKG - Ein Paketmanager, der Pakete über BitTorrent (und nun HTTP) herunterlädt.

# Caldera License (a.k.a 4-Clause BSD).
# Copyright (c) 2019-2020, Luiz Antônio Rangel et Projeto Pindorama;
# Read LICENSE @ master branch root (GitHub) for the complete license.

#############    Depends    ###############
# Korn Shell (93,PD);
# Python 3.(4,8);
# Libtorrent and Libtorrent bindings for Python 3.x;
# cURL;
# POSIX 7-Zip (p7zip);
# Sed;
# Awk;
# Cut;
# Grep;
# Otto's libaries.
##############     END       ##############

# TO DO:
# Terminar as funções pelo menos;
# Optimize it;
# Make it portable;
# Fix identation  (tab = two spaces);
# Write the remove() and install() function (and finish others!);
# Implement raw/-r option (and function!) for installing/removing/updating packages via an .psl file;
# Fix the inconsistent code style;
# Create a log function, for save every operation log in /var/otto/system/logs/otto_`date`. A little useless for now;
# Test if multiple packages install won't broke everything. If it does, try to fix with a for loop.

############# Export C locale #############
export LANG=C
export LC_ALL=${LANG}
##############     END       ##############

############# Export chdir alias ##########
# This shall be commented when /bin/sh already has a native "chdir" command/system call, for example zsh.
alias chdir='cd'
##############     END       ##############

############# Program Specifications ######
# Program Otto
# Version 0.4
export PKG_FORMT='.psl'
export INDEXFILE='.otidx'
export PKG_COMPSS='7z'
export HOST_OS=${HKERNEL}
##############     END       ##############

############## Include Files ##############
. /usr/lib/otto/colors.shi
. /usr/lib/otto/blink.shi
. /usr/lib/otto/txtwait.shi
. /usr/lib/otto/posix-alt.shi
##############     END       ##############

############## Global Variables/Subshells #
PKG_FILENAME=`/usr/bin/sed 's/ /./g' <<< $NAME`

##############     END       ##############

# Load the configuration file:
  if [ -f "/etc/make.cfg" ]; then
    . "/etc/make.cfg"
  else
    printf '%s\n' "${RED}ERROR$END: make.cfg not found!\nCopy this file from the installation media (or download it from the offcial repo) and configure it."
    exit 1
  fi

############## Script Functions ###########

############ ARE YA CHECKING SON? #########
Checkroot(){
  if [ "`id -u`" -ne 0 ]; then
    printf "${YELLOW}WARNING$END: It looks like you are not logged into toor nor root user...\nWould you like to install the program on the highest userland layer ($HIUSR) instead of installing directly on the root of the system?\n${YELLOW}WARNING$END: Some packages ${BOLD}cannot$END be installed on the highest userland layer under any circunstances.\nRegarding the first (and only) question: [Y,N]? "
    read -r ANTWORTEN
    if /usr/bin/grep -iq '^y' <<< "$ANTWORTEN"; then
      export USRDIR=${HIUSR}
      export USRBIN=${HIUSRBIN}
      export ETC=${HIETC}
      export SRCDIR=${HISRCDIR}
      export DIRISTATE=2
    else
      printf '%s\n' "Alright so, exiting..."
      exit 130
    fi
  else
    export USRDIR=${LOUSR}
    export USRBIN=${LOUSRBIN}
    export ETC=${LOETC}
    export SRCDIR=${LOSRCDIR}
    export DIRISTATE=1
  fi
}

CheckNetwork(){
  # POSIX regex that will remove 'https://' and anything after '.<tdl>'.
  # $MIRROR is applyed only in packages officially created, unofficial packages probabily will use some custom domain.
  local MIRROR=${MIRROR#*//}
  local MIRROR=${MIRROR%%/*} 
  
  printf '%s' "Checking network connection"
  txtwait
  if `timeout 12 /usr/bin/netcat $MIRROR 80 <<< "GET $MIRROR HTTP/1.0\n\n" > /dev/null 2>&1`; then
    printf '%s\n' "[ ${GREEN}O.K.$END ]"
  else
    printf '%s\n' "[ ${RED}FAILED$END ]"
    printf "${RED}ERROR$END: Apparently, this box isn't connected to the World Wide Web.\a\nIf you don't have a internet connection, try to download the raw package (a ${YELLOW}$PKG_FORMT$END which contains everything necessary to install the program), save it in a diskette/CD/SDCard/USB and install it using ${YELLOW}otto dig [raw|-r]$END.\nIf you expected to have networking on this box, do some checks. Check if the network daemon is running, if the drivers are enabled on the Kernel and if the physical devices are even working/turned on.\n"
    exit 1
  fi
}

CheckParameters(){
  if [ -z "$2" ]; then
    printf '%s\n' "${RED}ERROR$END: Insufficient parameters."
    exit 127
  fi
}

CheckDisk(){
  BENUTZT=`/usr/bin/df -m / | /usr/bin/tail -1 | /usr/bin/grep '[0-9]' | /usr/bin/awk '{print $3}'`
  DSKVERF=`/usr/bin/df -m / | /usr/bin/tail -1 | /usr/bin/grep '[0-9]' | /usr/bin/awk '{print $4}'`
  DSKGROSSE=$[$BENUTZT + $DSKVERF]
  PKGGROSSE_FILE=`/usr/bin/du -sk "$SRCDIR"/uncompressed-"$PKG_FILENAME"/src.tar | /usr/bin/awk '{print $1}'`
  PKGGROSSE_CALC=`/usr/bin/bc <<< "scale=3; $PKGGROSSE_FILE/1000"`
  printf "\
Estimated total disk space: "$DSKGROSSE"MB
Estimated used space: "$DSKVERF"MB
Estimated space available: "$BENUTZT"MB
Estimated space to be consumed (build files): "$PKGGROSSE_CALC"MB
Estimated space after install: `/usr/bin/bc <<< "scale=3; $DSKVERF - $PKGGROSSE_CALC"`MB
"  
}

CheckRawPackage(){
  if [ "$RAW_PKG" = '1' ]; then 
    # For uncompress
    PKGNM="$I" # I've called "I" because i couldn't think of a name, sorry.
    BASENAME=`basename $I`
    PKG_FILENAME=`/usr/bin/sed 's/.psl//' <<< $I`
    EXTR_CMD=`/usr/bin/7z x $I -o "$SRCDIR"/uncompressed-"$PKG_FILENAME"`
    EXTR_MSG="Extracting $BASENAME"
    # Source pkginfo
    SOURCE_PKGINFO=`. "$SRCDIR"/uncompressed-"$PKG_FILENAME"/pkginfo`
  else 
    # Run the DownloadPackage() function
    DownloadPackage
    # Source pkginfo
    SOURCE_PKGINFO=`. "$SRCDIR"/uncompressed-"$PKG_FILENAME"/pkginfo`
    # For uncompress
    EXTR_CMD=`/usr/bin/7z x "$SRCDIR"/"$PKG_FILENAME""$PKG_FORMT" -o "SRCDIR"/uncompressed-"$PKG_FILENAME" -bb1` # For uncompressing downloaded packages, local pkginfo needs to be sourcered first.
    EXTR_MSG="Extracting $PKG_FILENAME$PKG_FORMT"
  done
}

CheckDependencies(){
  for LIB in `printf '%s' "$DEPS"`; do
    if grep "$LIB" > /dev/null 2>&1 <<< `printf '%s\n' /lib/* /usr/lib/*`; then
      printf '%s\n' "$LIB is O.K."
    else
      printf '%s\n' "${RED}ERROR$END: $LIB isn't installed. Please, install the package that's corresponds to it."
  done
}

##############  Sure i am, dad.  ############

Uncompress(){
  printf '%s' "$EXTR_MSG"
  txtwait &
  $EXTR_CMD
  /usr/bin/tar -vxf "$SRCDIR"/uncompressed-"$PKG_FILENAME"/src.tar && rm -v "$SRCDIR"/uncompressed-"$PKG_FILENAME"/src.tar
}

Build(){
  # Scripts for building the package shall be minimal and pure POSIX
  /bin/sh "$SRCDIR"/uncompressed-"$PKG_FILENAME"/install/checkinstall
  /bin/sh "$SRCDIR"/uncompressed-"$PKG_FILENAME"/install/makebuild
}

GenerateLocalpkgmap(){
cat > /var/otto/installed/pkg/OTTO"$PKG"/pkgmap <<EOD
`cat "$SRCDIR"/uncompressed-"$PKG_FILENAME"/pkgmap`
EOD
} # This will load directory variables (ex: low /usr or high /usr?) for a specific install, in theory.

#GenerateLocalpkginfo(){
#cat > /var/otto/installed/pkg/OTTO"$PKG"/pkginfo <<EOD
#`cat "$SRCDIR"/uncompressed-"$PKG_FILENAME"/pkginfo`
#EOD
#}

AutoClean(){
  if [ "$AUTOCLEAN" = 'YES' ]; then
    printf '%s\n' "Cleaning "$CATEGORY"/"$PKG" sources." ; rm -rvf "$SRCDIR"/"uncompressed-*" && rm -vf "$SRCDIR"/*"$PKG_FORMT"
  else
    printf '%s\n' "${YELLOW}WARNING$END: Autocleaning is disabled, trash (build files and ${YELLOW}$PKG_FORMT$END's) will stay in the system (in the $SRCDIR) until some user with the needed permissions deletes them."
  fi
}

DownwloadPackage(){
  if [ "$SYNC_TYPE" = 'bittorrent' ]; then
    TORRENT="$PKGNM"
    PKG=`/usr/bin/cut -d '/' -f 2 <<< "$TORRENT"`
    CATEGORY=`/usr/bin/cut -d '/' -f 1 <<< "$TORRENT"`
    . "$PKGDIR"/"$TORRENT"/pkginfo # Source local pkginfo
    /usr/bin/pico-torrent -s -f "$PKGDIR"/"$TORRENT"/pkgp2p -d "$SRCDIR"
  elif [ "$SYNC_TYPE" = 'http' ] || [ "$SYNC_TYPE" = 'ftp' ]; then
    PKG=`/usr/bin/cut -d '/' -f 2 <<< "$PKGNM"`
    CATEGORY=`/usr/bin/cut -d '/' -f 1 <<< "$PKGNM"`
    . "$PKGDIR"/"$PKGNM"/pkginfo # Source local pkginfo
    chdir $SRCDIR && { /usr/bin/curl -O -# "`cat "$PKGDIR/$PKG/pkglink"`" ; cd -;}
  else
    printf "${RED}ERROR$END: ${YELLOW}SYNC_TYPE$END not set @ /etc/make.cfg.\nAre you trying to install a local package? Use ${YELLOW}-r$END after ${YELLOW}-d$END"
 fi
}

InstallPackage(){
  printf "Packages to install: ${#@}\n" 
  for PKGNM in "$@"; do
    CheckRawPackage
    Uncompress
    $SOURCE_PKGINFO # Source package extracted pkginfo (i know, it's messy but it works in theory)
    PKGNM="$CATEGORY/$PKG"
    CheckDependencies
    CheckDisk
    Build
    mkdir /var/otto/installed/pkg/OTTO"$PKG"
    GenerateLocalpkgmap
  # GenerateLocalpkginfo
    printf '%s\n' "$PKGNM-$VERSION" > /var/otto/installed/contents
  done
  AutoClean
  exit 0
}

RemovePackage(){
  for PKGNM in "$@"; do 
    PKG=`printf '%s' "$PKGNM" | /usr/bin/cut -d "/" -f 2`
    CATEGORY=`printf '%s' "$PKGNM" | /usr/bin/cut -d "/" -f 1`
    printf '%s' "Removing $CATEGORY/$PKG"
    txtwait &
    < /var/otto/installed/pkg/OTTO"$PKG"/pkgmap /usr/bin/xargs rm -r  # Wait, do this work? Really awesome to see that i didn't need that cat.
    /usr/bin/sed -i "/$PKGNM/d" /var/otto/installed/contents
  done
  exit 0
}

Update(){
  chdir "$PKGDIR"
  /usr/bin/curl -O -OD "$MIRROR"/pkgindex"$INDEXFILE"
  /usr/bin/7z x pkgindex"$INDEXFILE"
  printf '%s\n' "Package index updated."
  exit 0
}

MakePackage(){
  
}

ListPackages(){
  if [ -f "/var/otto/installed/contents" ]; then
    lines "/var/otto/installed/contents"
    exit 0
  else
    printf "${BLK_RED}ERROR:$BLK_END package list not found! This isn't a good thing...\a\n"
    exit 140
  fi
}

Info(){ printf "\
Otto-PKG @ 0.4
Paketformat: $PKG_FORMT
Betriebssystem: $HOST_OS

Copyright (c) 2019-2020 Luiz Antonio Rangel et Project Pindorama.

lib-txtampel und lib-posixalt (@ ${LOUSR}/lib/otto)
Copyright (c) 2019-2020 Jefferson Rocha et MazonOS Team.
Copyright (c) 2019-2020 Dylan Araps et K1ss Linux/pure sh bible.
Copyright (c) 2019-2020 Luiz Antonio Rangel et Project Pindorama.
"
exit 0
}

Help(){
    export LANG=en_US.UTF-8
    export LC_ALL=${LANG}
    printf "\
${GREEN}Otto, eine Paketverwaltungs-Toolchain.$END
${YELLOW}otto {-H|-I|-f|-d|-b|-u|-i|-l} <category>/<pkg>| (-d|-u|-b) -r <pkg>$PKG_FORMT$END
${GREEN}> help (-H)    - Show this help message.
> info (-I)    - List info about the software.
> find (-f)    - Search for content in Otto'\''s files.
> dig  (-d)    - Install package.
> bury (-b)    - Remove package.
> up2date (-u) - Update repository index and packages.
> mkpkg (-i)   - Build a package (using source code or binaries).
> list  (-l)   - List installed packages.$END

✠ GOTT MIT UNS ✠
"
exit 0
}

find(){
  grep "$1" "`which otto`" "/etc/make.cfg"
  exit 0
}

##############     END      #################

############## CASE DO SCRIPT #################
case $1 in
  help|-H*) Help ;;
  info|-I*) Info ;;
  find|-f*) find "$@" ;;
  dig|-d*) Checkroot && InstallPackage "$@" ;;
  bury|-b*) CheckParameters "$@" && Checkroot && RemovePackage "$@" ;;
  up2date|-u*) Checkroot && Update "$@" ;;
  mkpkg|-i*) Checkroot && MakePackage "$2" ;;
  list|-l*) ListPackages "$@" ;;
  chknet*) CheckNetwork;;
  *) Help ;;
esac
case $2 in
  -r*) export RAW_PKG=1 ;;
esac
############## FIM DO CASE ####################
